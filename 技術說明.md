# 技術說明：量子安全混合加密通訊系統 (Quantum-Secure Hybrid Communication System)

> **文件狀態**: 正式版
> **版本**: v1.0
> **生成日期**: 2026-01-15
> **專案路徑**: `c:\PJ02`

---

## 1. 系統概述 (System Overview)

本系統為一套具備 **抗量子電腦攻擊 (Post-Quantum)** 能力的即時通訊平台。不同於僅使用模擬數據的演示專案，本系統整合了真實的 **Kyber-768** 密鑰封裝機制 (KEM)，並結合傳統的高效 **X25519** 橢圓曲線演算法，建立「混合式加密架構 (Hybrid Architecture)」。前端介面採用極致的 Cyberpunk 與戰情中心風格，展現未來科技感。

### 1.1 核心價值
*   **真實性**: 實際調用 `kyber-py` 執行後量子演算法運算。
*   **混合防禦**: "Defense in Depth" 策略，同時抵禦傳統超級電腦與未來量子電腦攻擊。
*   **前向保密 (PFS)**: 每次會話生成獨立金鑰，即使主金鑰洩漏也不影響過往通訊。

---

## 2. 技術堆疊 (Technology Stack)

| 類別 | 技術/工具 | 用途與規格 |
| :--- | :--- | :--- |
| **程式語言** | **Python 3.10+** | 核心邏輯與介面開發 |
| **PQC 演算法** | **Kyber-768** | NIST 標準化後量子密鑰封裝 (Level 3 Security) |
| **ECC 演算法** | **X25519** | 高效能橢圓曲線密鑰交換 (RFC 7748) |
| **對稱加密** | **AES-256-GCM** | 數據加密與完整性驗證 (Authenticated Encryption) |
| **雜湊/KDF** | **SHA3-512 / HKDF** | 混合金鑰衍生函數 (Layered KDF) |
| **網路傳輸** | **TCP Socket** | 原始 Socket 通訊，自定義封包協議 |
| **GUI 框架** | **Tkinter** | 高度客製化的駭客風格圖形介面 |

---

## 3. 執行過程與協定 (Execution Process & Protocol)

系統運作核心在於 `innovative_hybrid_kem.py` 中定義的混合握手流程。

### 3.1 握手協議 (The Hybrid Handshake)

這是一個 1-RTT (Round Trip Time) 的高效握手協定。

1.  **初始階段 (Initialization)**
    *   Client 與 Server 各自生成臨時的 **X25519** 金鑰對。
    *   Server 開啟監聽 (`0.0.0.0:8888`)。

2.  **Client Hello (傳送)**
    *   **PQC KeyGen**: Client 呼叫 `Kyber768.keygen()` 生成 `(pk, sk)`。
    *   **打包**: 使用 `struct` 將以下數據打包為二進制格式：
        *   `Salt` (32 bytes): 隨機鹽值。
        *   `Timestamp` (8 bytes): 防重放攻擊。
        *   `Entropy Proof` (32 bytes): HMAC-SHA3-512 完整性證明。
        *   `Session ID` (32 bytes): 會話識別碼。
        *   `ECC Public Key` (32 bytes): X25519 公鑰。
        *   `Kyber Public Key` (1184 bytes): 巨大的後量子公鑰。
    *   **傳輸**: 發送 Protocol ID (`\x02`) + 長度 + 打包數據。

3.  **Server Response (接收與封裝)**
    *   Server 解析 Client Hello 封包。
    *   **PQC Encaps**: Server 使用 Client 的 Kyber 公鑰執行 `Kyber768.encaps(pk)`，生成：
        *   `Ciphertext` (1088 bytes): 需回傳給 Client。
        *   `Shared Secret (PQC)` (32 bytes): 伺服器端保留。
    *   **ECC Exchange**: Server 使用 Client 的 ECC 公鑰執行 ECDH，算出 `Shared Secret (ECC)`。
    *   **KDF**: 結合 PQC 與 ECC 的秘密，透過多層 HKDF 算出 `Session Key`。
    *   **回傳**: 將 `Ciphertext` 與 `Server ECC Public Key` 回傳給 Client。

4.  **Client Finalize (解封裝)**
    *   Client 收到 Server 回應。
    *   **PQC Decaps**: Client 使用 Kyber 私鑰執行 `Kyber768.decaps(sk, ciphertext)`，還原出 `Shared Secret (PQC)`。
    *   **ECC Exchange**: 計算出相同的 `Shared Secret (ECC)`。
    *   **KDF**: 生成與 Server 完全一致的 `Session Key`。

### 3.2 加密通訊 (Secure Transport)

握手完成後，所有訊息使用 **AES-256-GCM** 傳輸。

*   **IV (Initial Vector)**: 每條訊息隨機生成 12 bytes IV，絕不重複。
*   **Tag**: 16 bytes auth tag，確保訊息未被竄改。
*   **Payload**: JSON 格式 `{"iv": "<hex>", "ciphertext": "<hex>", "tag": "<hex>"}`。

---

## 4. 真實代碼結構 (Source Code Analysis)

以下為專案關鍵文件的真實內容分析：

### 4.1 核心加密層 (`network/innovative_hybrid_kem.py`)

這是系統的大腦，負責所有密碼學運算。

```python
class InnovativeHybridKEM:
    # 嚴格定義的常量，符合 NIST FIPS 203 草案
    PQC_CIPHERTEXT_LENGTH = 1088
    PQC_PUBLIC_KEY_LENGTH = 1184 
    
    def server_pqc_encapsulate(self, client_pub_key: bytes) -> Tuple[bytes, bytes]:
        # 真實調用 Kyber-768
        shared_secret, ciphertext = Kyber768.encaps(client_pub_key)
        return ciphertext, shared_secret

    def derive_final_key(self, ...):
        # 混合 KDF：將傳統與後量子秘密混合
        # input: ecc_shared, pqc_shared, salt, timestamp
        context = b"HybridKEM-v2.2" + timestamp.to_bytes(...)
        master_key = self._layered_kdf([ecc_shared, pqc_shared], context)
```

### 4.2 用戶端後端 (`network/client.py`)

負責管理 Socket 連線與狀態機。

```python
def perform_handshake(self) -> bool:
    # 1. 生成 Kyber Keys
    pqc_pk, pqc_sk = self.kem.client_pqc_keygen()
    
    # 2. 發送握手包
    handshake_data = self.kem.generate_handshake_package(pqc_pk)
    self.client_socket.sendall(...)
    
    # 3. 處理伺服器回應與解封裝
    if response.get('success'):
        pqc_ciphertext = bytes.fromhex(response['pqc_ciphertext'])
        pqc_shared = self.kem.client_pqc_decapsulate(pqc_ciphertext, pqc_sk)
        # ... 握手成功，通道建立
```

### 4.3 伺服器後端 (`network/server.py`)

多執行緒架構，為每個連線維護獨立的加密狀態。

```python
def _handle_client(self, conn, addr):
    # 解析 Client Hello
    package = connection_kem.parse_handshake_package(data)
    
    # Kyber 封裝 (這是 PQC 的核心步驟)
    pqc_c, pqc_s = connection_kem.server_pqc_encapsulate(package['pqc_public_key'])
    
    # 這些步驟確保了即使未來量子電腦破解了 ECC，
    # 攻擊者仍無法解開 Kyber encapsulation 取得 Shared Secret。
```

---

## 5. 操作演示 (Operation)

### 5.1 啟動 Server
執行後，您將看到一個「資安戰情中心」風格的儀表板。
```bash
python network/gui_server.py
```
> **狀態**: `LISTENING 0.0.0.0:8888`

### 5.2 啟動 Client
執行後，將開啟一個綠色調的 Cyberpunk 終端機介面。
```bash
python network/gui_client.py
```

### 5.3 執行流程
1.  **Client**: 點擊 `> INIT CONNECTION`。控制台顯示 `[SYSTEM] Connected to Server`。
2.  **Client**: 點擊 `> EXECUTE HANDSHAKE`。
    *   系統日誌將瘋狂滾動，顯示 `Generating Kyber-768 Keypair...`。
    *   完成後顯示 `[SUCCESS] Secure Channel Established (AES-256-GCM)`.
3.  **通訊**: 發送訊息 "Hello Quantum World"。
    *   網路封包中傳輸的是完全加密的雜湊值。
    *   Server 端即時解密並顯示。

---

## 6. 安全性總結 (Security Summary)

| 攻擊向量 | 防禦機制 | 結果 |
| :--- | :--- | :--- |
| ** Shor's Algorithm (量子)** | **Kyber-768** (Lattice-based cryptography) | **安全** |
| **中間人攻擊 (MITM)** | **AES-GCM Auth Tag** + HKDF Context Binding | **安全** |
| **重放攻擊 (Replay)** | **Timestamp** + **Unique Session ID** | **安全** |
| **金鑰洩漏** | **Forward Secrecy** (每次會話重新生成 Ephemeral Keys) | **安全** |

本系統已實作完備的後量子遷移路徑，是未來安全通訊的標準參考實作。
